import { describe, test, expect, beforeEach, mock } from "bun:test";
import { POST, GET } from "@/app/api/books/[id]/progress/route";
import { NextRequest } from "next/server";

// Mock modules
const mockConnectDB = mock(() => Promise.resolve());
const mockBookFindById = mock(() => null);
const mockProgressLogFind = mock(() => ({ sort: mock(() => ({ limit: mock(() => null) })) }));
const mockProgressLogFindOne = mock(() => ({ sort: mock(() => ({ limit: mock(() => null) })) }));
const mockProgressLogCreate = mock(() => ({}));
const mockReadingStatusFindOne = mock(() => null);
const mockUpdateStreaks = mock(() =>
  Promise.resolve({
    currentStreak: 1,
    longestStreak: 1,
    lastActivityDate: new Date(),
    totalDaysActive: 1,
  })
);
const mockRevalidatePath = mock(() => {});

// Setup module mocks
mock.module("@/lib/db/mongodb", () => ({
  connectDB: mockConnectDB,
}));

mock.module("@/models/Book", () => ({
  default: {
    findById: mockBookFindById,
  },
}));

mock.module("@/models/ProgressLog", () => ({
  default: {
    find: mockProgressLogFind,
    findOne: mockProgressLogFindOne,
    create: mockProgressLogCreate,
  },
}));

mock.module("@/models/ReadingStatus", () => ({
  default: {
    findOne: mockReadingStatusFindOne,
  },
}));

mock.module("@/lib/streaks", () => ({
  updateStreaks: mockUpdateStreaks,
}));

mock.module("next/cache", () => ({
  revalidatePath: mockRevalidatePath,
}));

describe("Progress API - GET", () => {
  beforeEach(() => {
    mockConnectDB.mockClear();
    mockProgressLogFind.mockClear();
  });

  test("returns progress logs for a book", async () => {
    // Arrange
    const mockProgressLogs = [
      {
        _id: "1",
        bookId: "book1",
        currentPage: 100,
        currentPercentage: 50,
        progressDate: new Date(),
        pagesRead: 50,
      },
    ];

    const sortMock = mock(() => mockProgressLogs);
    const findMock = mock(() => ({ sort: sortMock }));
    mockProgressLogFind.mockReturnValueOnce({ sort: sortMock });

    const request = new NextRequest("http://localhost:3000/api/books/book1/progress");
    const params = { params: { id: "book1" } };

    // Act
    const response = await GET(request, params);
    const data = await response.json();

    // Assert
    expect(mockConnectDB).toHaveBeenCalled();
    expect(mockProgressLogFind).toHaveBeenCalledWith({ bookId: "book1" });
    expect(response.status).toBe(200);
  });

  test("handles errors gracefully", async () => {
    // Arrange
    mockProgressLogFind.mockRejectedValueOnce(new Error("Database error"));

    const request = new NextRequest("http://localhost:3000/api/books/book1/progress");
    const params = { params: { id: "book1" } };

    // Act
    const response = await GET(request, params);
    const data = await response.json();

    // Assert
    expect(response.status).toBe(500);
    expect(data.error).toBe("Failed to fetch progress");
  });
});

describe("Progress API - POST", () => {
  beforeEach(() => {
    mockConnectDB.mockClear();
    mockBookFindById.mockClear();
    mockProgressLogFindOne.mockClear();
    mockProgressLogCreate.mockClear();
    mockUpdateStreaks.mockClear();
    mockRevalidatePath.mockClear();
  });

  test("logs progress by page number", async () => {
    // Arrange
    const mockBook = {
      _id: "book1",
      title: "Test Book",
      totalPages: 300,
    };
    mockBookFindById.mockResolvedValueOnce(mockBook);

    const mockLastProgress = {
      currentPage: 50,
      currentPercentage: 16.67,
    };
    const findOneMock = mock(() => ({
      sort: mock(() => ({
        limit: mock(() => mockLastProgress),
      })),
    }));
    mockProgressLogFindOne.mockReturnValueOnce({
      sort: () => ({
        limit: () => mockLastProgress,
      }),
    });

    const mockNewProgress = {
      _id: "progress1",
      bookId: "book1",
      currentPage: 100,
      currentPercentage: 33.33,
      pagesRead: 50,
      progressDate: new Date(),
    };
    mockProgressLogCreate.mockResolvedValueOnce(mockNewProgress);

    const requestBody = {
      currentPage: 100,
      notes: "Great chapter!",
    };

    const request = new NextRequest("http://localhost:3000/api/books/book1/progress", {
      method: "POST",
      body: JSON.stringify(requestBody),
    });
    const params = { params: { id: "book1" } };

    // Act
    const response = await POST(request, params);
    const data = await response.json();

    // Assert
    expect(mockConnectDB).toHaveBeenCalled();
    expect(mockBookFindById).toHaveBeenCalledWith("book1");
    expect(mockProgressLogCreate).toHaveBeenCalledWith(
      expect.objectContaining({
        bookId: "book1",
        currentPage: 100,
        notes: "Great chapter!",
      })
    );
    expect(mockUpdateStreaks).toHaveBeenCalled();
    expect(mockRevalidatePath).toHaveBeenCalledWith("/");
    expect(mockRevalidatePath).toHaveBeenCalledWith("/stats");
    expect(response.status).toBe(200);
  });

  test("returns 404 when book not found", async () => {
    // Arrange
    mockBookFindById.mockResolvedValueOnce(null);

    const requestBody = { currentPage: 100 };
    const request = new NextRequest("http://localhost:3000/api/books/book1/progress", {
      method: "POST",
      body: JSON.stringify(requestBody),
    });
    const params = { params: { id: "book1" } };

    // Act
    const response = await POST(request, params);
    const data = await response.json();

    // Assert
    expect(response.status).toBe(404);
    expect(data.error).toBe("Book not found");
  });

  test("returns 400 when neither currentPage nor currentPercentage provided", async () => {
    // Arrange
    const mockBook = {
      _id: "book1",
      title: "Test Book",
      totalPages: 300,
    };
    mockBookFindById.mockResolvedValueOnce(mockBook);
    mockProgressLogFindOne.mockReturnValueOnce({
      sort: () => ({
        limit: () => null,
      }),
    });

    const requestBody = { notes: "Test" }; // No currentPage or currentPercentage
    const request = new NextRequest("http://localhost:3000/api/books/book1/progress", {
      method: "POST",
      body: JSON.stringify(requestBody),
    });
    const params = { params: { id: "book1" } };

    // Act
    const response = await POST(request, params);
    const data = await response.json();

    // Assert
    expect(response.status).toBe(400);
    expect(data.error).toBe("Either currentPage or currentPercentage is required");
  });

  test("calculates pages read correctly", async () => {
    // Arrange
    const mockBook = {
      _id: "book1",
      title: "Test Book",
      totalPages: 300,
    };
    mockBookFindById.mockResolvedValueOnce(mockBook);

    const mockLastProgress = {
      currentPage: 50,
      currentPercentage: 16.67,
    };
    mockProgressLogFindOne.mockReturnValueOnce({
      sort: () => ({
        limit: () => mockLastProgress,
      }),
    });

    const mockNewProgress = {
      _id: "progress1",
      bookId: "book1",
      currentPage: 150,
      currentPercentage: 50,
      pagesRead: 100, // Should be 150 - 50 = 100
      progressDate: new Date(),
    };
    mockProgressLogCreate.mockResolvedValueOnce(mockNewProgress);

    const requestBody = { currentPage: 150 };
    const request = new NextRequest("http://localhost:3000/api/books/book1/progress", {
      method: "POST",
      body: JSON.stringify(requestBody),
    });
    const params = { params: { id: "book1" } };

    // Act
    const response = await POST(request, params);
    const data = await response.json();

    // Assert
    expect(mockProgressLogCreate).toHaveBeenCalledWith(
      expect.objectContaining({
        pagesRead: 100,
      })
    );
  });
});
